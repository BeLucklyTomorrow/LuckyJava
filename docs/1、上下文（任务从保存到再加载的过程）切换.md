#### 1、上下文（任务从保存到再加载的过程）切换

- 使用Lmbench3可以测量上下文切换的时长。


- 使用vmstat可以测量上下文切换的次数。


#### 2、如何减少上下文切换

- 无锁并发编程
- CAS算法
- 使用最少线程和使用协程

#### 3、死锁

- 避免一个线程同时获取多个锁
- 避免一个线程在锁内同时占用多个资源，尽量保证每个锁只占用一个资源
- 尝试使用定时锁，使用lock.tryLock（timeout）来替代使用内部锁机制
- 对于数据库锁，加锁和解锁必须在一个数据库连接里，否则会出现解锁失败的情况

#### 4、资源限制

- 硬件资源（带宽、硬盘读写速度、cpu处理速度等）
- 软件资源（数据库连接数、socket连接数等）
- 引发的问题：由于资源限制，并发执行反而比单线程更慢。
- 解决问题
  1. 硬件资源：使用集群等
  2. 软件资源：使用资源池将资源复用。比如：使用连接池将数据库和socket连接复用。

#### 5、synchronized

- 普通同步方法（当前实例对象）

- 静态同步方法（当前类的Class对象）

- 同步方法块（括号里配置的对象）

  [^JVM基本进入和退出MOnitor对象来实现方法同步和代码块同步]: 
  [^代码块同步使用monitorenter和monitorexit指令实现，它们必须配对。]: 

  ```java
  Synchonized(this){
  	monitorenter指令（尝试获取对象所对应的monitor的所有权，即尝试获取对象的锁）
  	执行代码....
  	monitorexit指令
  }
  ```

#### 6、java对象头（synchronized用的锁的地方）

###### 	对象头存储：HashCode、分代年龄和锁标记位

- 对象数组类型：虚拟机3个字（word）存储
- 对象非数组：2个字存储